# 13.01.2024 Эволюция средств обеспечения безопасности памяти

## Содержание

- [13.01.2024 Эволюция средств обеспечения безопасности памяти](#13012024-эволюция-средств-обеспечения-безопасности-памяти)
  - [Содержание](#содержание)
  - [Введение](#введение)
  - [Проблема](#проблема)
  - [Безопасность и ошибки при работе с памятью](#безопасность-и-ошибки-при-работе-с-памятью)
  - [Эволюция средств обеспечения безопасности памяти](#эволюция-средств-обеспечения-безопасности-памяти)
    - [Сборка мусора. Lisp](#сборка-мусора-lisp)
    - [Структурные блоки. ALGOL 60](#структурные-блоки-algol-60)
    - [Проверка выхода за границы массива. ALGOL 60](#проверка-выхода-за-границы-массива-algol-60)
    - [Тэгированная архитектура. B5000](#тэгированная-архитектура-b5000)
    - [Сегментная память. B5000](#сегментная-память-b5000)
    - [RAII. C++](#raii-c)
    - [Stack protector. GCC](#stack-protector-gcc)
    - [Рандомизация размещения адресного пространства. Linux](#рандомизация-размещения-адресного-пространства-linux)
    - [Интерпретация машинного кода. Valgrind](#интерпретация-машинного-кода-valgrind)
    - [Аллокатор спец. назначения. DieHard](#аллокатор-спец-назначения-diehard)
    - [Инструменация кода. Address Sanitazer](#инструменация-кода-address-sanitazer)
    - [Тэгированная архитектура. LowRISC, Arm MTE](#тэгированная-архитектура-lowrisc-arm-mte)
    - [Lifetimes \& Borrow Checker. Rust](#lifetimes--borrow-checker-rust)
  - [Ссылки](#ссылки)

## Введение

## Проблема


## Безопасность и ошибки при работе с памятью

[Безопасность памяти][5] - состояние программы при котором все ее
доступы к памяти корректны.

Доступ к памяти корректен тогда и только тогда, когда его выполнение
не может привести к ошибке программы.

Ошибка программы - ошибка, приводящая к неожиданному поведению
программы и, как следствие, выдаче некорректного результата.

## Эволюция средств обеспечения безопасности памяти

- <https://en.wikipedia.org/w/index.php?title=Memory_safety&oldid=1185104456>
- <https://en.wikipedia.org/wiki/Memory_protection>

### Сборка мусора. Lisp

Поскольку ручное управление памятью привносит с собой возможность ошибиться,
то можно попытаться избежать таких ошибок, введя механизм автоматического
управления памятью - сборку мусора, который бы сам аллоцировал и деаллоцировал
память, огородя нас от ошибок при работе с аллокатором вроде [use-after-free],
[double-free] и [invalid-free]. Такое архитектурное решение было принято при
дизайне языка программирования [LISP] в 1959 году. В райнтайм языка ввели
процесс [reclamation], который отмечал неиспользуемую память как мусор,
позволявшую программисту не думать о памяти. Кроме того [LISP] сам по себе
был достаточно высокоуровневым и не оперировал такими понятиями как указатель
и буффер. Ввиду отсутствия возможности ручного управления памятью [LISP],
многие считают его memory-safe языком.

- <http://www-formal.stanford.edu/jmc/recursive.pdf>
- <https://www.gnu.org/software/emacs/manual/html_node/elisp/Garbage-Collection.html>

### Структурные блоки. ALGOL 60

Код на языке Алгол 60 состоял из блоков. Блок представлял из себя
объявления локальных переменных и список инструкций.

```ada
begin integer X;
  X := 5;
  begin integer X;
    X := 4;
  end
  print (X);
end;
```

Аллокация выделение памяти под локальные переменные происходило при
входе в блок на стеке, а освобождение при выходе. Выделение памяти на куче
остутсвовало, что снова избавляло программистов от ошибок при работе с
аллокаторами.

### Проверка выхода за границы массива. ALGOL 60

Кроме того в Algol 60 была введена обязательная проверка
на нахождение индекса в рамках массива (range-check), вставляемая
компилятором. С тех пор большинство языков программирования
придерживаются предпочитают не опускать проверки при доступе к
элементам массива. Ненужные вхождения range-check могут быть опущены
компилятором, что снижает оверхед на производительность программы.

- <https://en.wikipedia.org/wiki/ALGOL_60>
- <https://web.eecs.umich.edu/~bchandra/courses/papers/Naure_Algol60.pdf>
- <https://www.cl.cam.ac.uk/teaching/0910/ConceptsPL/Algol-Pascal.pdf>
- <https://jcsites.juniata.edu/faculty/rhodes/lt/blockstr.htm>
- <https://code.fandom.com/wiki/Algol_60>

### Тэгированная архитектура. B5000

В 1961 году мир увидел мейнфрейм B5000 со [стековой архитектурой].
Одной из интересных нововведений данной машины было использование
нескольких бит в машинных словах для кодирования типа хранимых данных,
чтобы различать неинициализированные данные, код, индексы, числа с
плавающей точкой, адреса возврата и др. Это помогало предотвращать
перезапись адреса возврата, использование неинициализированных
переменных, неправильную интерпретацию данных.

- <https://www.memorymanagement.org/glossary/t.html#tagged.architecture>
- <https://homepage.cs.uiowa.edu/~dwjones/arch/notes/11burroughs.html>
- <https://dl.acm.org/doi/pdf/10.1145/3533704>
- <https://en.wikipedia.org/wiki/Tagged_architecture>
- <https://en.wikipedia.org/wiki/Burroughs_Large_Systems>

### Сегментная память. B5000

Также B5000 имел сегментную память с разграничением доступа.
Каждому сегменту соответствовал набор флагов, характеризующих
ограничения на доступ к памяти: чтение, запись, исполнение.

- <https://en.wikipedia.org/wiki/Memory_segmentation>
- <https://homes.cs.washington.edu/~levy/capabook/Chapter1.pdf>

### RAII. C++

С++ зародился в 1985 году и представил миру идиому Resource Acquisition
Is Initialization - механизм, связывающий захват и освобождение ресурса
с временем жизни соответвующего ему объекта. Идиома использует стуктурные
блоки, определяющие время жизни объекта. При создании объекта ресурс
захватывается в коде конструктора, а отпускается в деструкторе, который
вызывается в конце блока, либо о время stack unwinding. Для того, чтобы
объект смог пережить скоуп, в которой объявлен, была введена семантика
перемещения. Таким образом мы не управляем памятью вручную, а делегируем
это высокоуровневым абстракциям. Подход используется в том числе и языке
программирования Rust.

- <https://en.cppreference.com/w/cpp/language/raii>
- <https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization>

### Stack protector. GCC

Канарейки, защищающие адрес возврата из функции, предотвращают атаки
с помощью переполнения буффера на стеке. Компилятор инструментирует код
программы, вставляя в сгенерированный код инструкции, помещающие
специальное значение перед адресом возврата, а далее проверяющие то, что
оно не изменилось перед выходом из функции. Таким образом при попытке
перезаписи адреса возврата будет перезаписана канарейка, наш код это
заметит и аварийно завершит выполнение программы, не допустив атаку.
Чтобы атакующий не смог подменить канарейку, ее значение генерируется
случайно средствами операционной системы.

- <https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries>
- <https://www.usenix.org/legacy/publications/library/proceedings/sec98/full_papers/cowan/cowan_html/cowan.html>

### Рандомизация размещения адресного пространства. Linux

В 2001 году в Linux была добавлена "Рандомизация расположения адресного
пространства". Этот метод защиты, который рандомизирует адреса памяти
процессов в попытке предотвратить формы эксплуатации, которые основаны
на знании точного местоположения объектов процесса.

- <https://www.mdpi.com/2076-3417/9/14/2928>

### Интерпретация машинного кода. Valgrind

В 2002 года был создан Valgrind - набор инструментов, которые могут
автоматически обнаруживать множество ошибок управления памятью и потоковой
передачей и детально профилировать программы. Его преимуществом является
хорошая точность и отстутствие необходимости иметь исходный код программы.
Valgrind Memcheck следит за корректностью выполняемых действий в программе,
интерпретируя машинный код, из-за чего сильно замедляет выполнение, что
делает его непригодным для отладки больших приложений и запуска в
продуктовой среде.

- <https://valgrind.org/docs/pubs.html>

### Аллокатор спец. назначения. DieHard

Очередными неинтрузивнымы инструментами для отладки работы с памятью
являются специальные аллокаторы памяти, использующие механизм виртуальной
памяти для аллокации блоков так, чтобы выход за их пределы вызывал
Segmentation Fault. Они размещают блоки в конце или начале новой страницы,
а следующую за ней страницу отмечают недоступной для записи и чтения. Это
позволяет с большей вероятностью обнаружить выход за пределы массива.

- <https://github.com/emeryberger/DieHard>
- <https://github.com/emeryberger/DieHard/blob/master/docs/pldi2006-diehard.pdf>

### Инструменация кода. Address Sanitazer

AddressSanitizer - быстрый инструмент на основе компилятора для обнаружения
ошибок памяти. Он обнаруживает: stack/heap buffer overflow,
use after free/scope, double/wild free. Принцип работы заключается в том,
чтобы аннотировать недоступную память и в рантайме проверять доступы к
памяти на корректность. Делается это через интструментацию кода. В среднем
замедляет программу в 2 раза, но может быть гибко настроен для использования
в проде, а также имеет Hardware Accelerated реализации на основе тэгирования
памяти.

- <https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf>

### Тэгированная архитектура. LowRISC, Arm MTE

Да-да, идея тэггированной архитектуры актуальна и по сей день.

В 2014 году LowRISC предложили ввести по 2битному тегу, хранимые
в отдельной области памяти на каждый байт информации в памяти.

| Тэг | Значение                    |
|-----|-----------------------------|
| 00  | No effect                   |
| 01  | Exception on read           |
| 10  | Exception on write          |
| 11  | Exception on read or write  |

С их помощью аппаратура может проверять доступ к памяти на
корректность и кидать исключение при обнаружении ошибки. Для снижения
отрицательного эффекта на производительность программы предлагается
делать это параллельно. Для поддержке данного механизма требуется
добавление команд для управления тегами в систему команд, а также
обновление компиляторов и кода аллокаторов для их использования.

- <https://www.cl.cam.ac.uk/~jrrk2/downloads/lowRISC-memo-2014-001.pdf>

Интересное решение - [ARM Memory Tagging Extension] - было внедрено
в их процессоры в 2015 году. Идея заключается в том, чтобы
отдать 4 неиспользуемые бита адреса указателя на некоторый тэг, означающий
цвет. Байты памяти также аннотируются цветом в отдельно выделенной
области памяти. При разыменовании указателя аппаратура асинхронно проверяет
совпадение цветов указателя и соответствующей памяти. Поскольку есть
шанс совпадения цветов, данный метод защиты является вероятностным.

- <https://www.youtube.com/watch?v=UwMt0e_dC_Q>
- <https://arxiv.org/pdf/2209.00307.pdf>
- <https://security.googleblog.com/2019/08/adopting-arm-memory-tagging-extension.html>

### Lifetimes & Borrow Checker. Rust

Главной особенностью языка Rust является расширение системы типов
специальными тэгами, аннотирующими время жихни объекта и позволяющие
компилятору на этапе семантического анализа находить dangling-reference и
use-after-free. С помощью аннотаций времени жизни Rust дополняет RAII,
делает его удобнее и безопаснее.

- <https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html>

## Ссылки

[2]: https://www.scala-lang.org
[3]: https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-1.html#jvms-1.2
[4]: https://www.cse.cuhk.edu.hk/~taoyf/course/comp3506/lec/ram.pdf
[5]: https://digital.car.chula.ac.th/cgi/viewcontent.cgi?article=3284&context=chulaetd
