# 13.01.2024 Эволюция средств обеспечения безопасности памяти

## Содержание

- [13.01.2024 Эволюция средств обеспечения безопасности памяти](#13012024-эволюция-средств-обеспечения-безопасности-памяти)
  - [Содержание](#содержание)
  - [Введение](#введение)
  - [Проблема](#проблема)
  - [Безопасность и ошибки при работе с памятью](#безопасность-и-ошибки-при-работе-с-памятью)
  - [Эволюция средств обеспечения безопасности памяти](#эволюция-средств-обеспечения-безопасности-памяти)
    - [1944 год. Гарвардская архитектура. Марк 1](#1944-год-гарвардская-архитектура-марк-1)
    - [1959 год. Сборка мусора. Lisp](#1959-год-сборка-мусора-lisp)
    - [1960 год. Проверка выхода за границы массива. ALGOL 60](#1960-год-проверка-выхода-за-границы-массива-algol-60)
    - [1961 год. Тэгированная архитектура. B5000](#1961-год-тэгированная-архитектура-b5000)
    - [1961 год. Сегментная память. B5000](#1961-год-сегментная-память-b5000)
    - [1962 год. Страничная память. Atlas](#1962-год-страничная-память-atlas)
    - [1964 год. Ключи защиты памяти. System/360](#1964-год-ключи-защиты-памяти-system360)
    - [1970 год. Адресация, основанная на возможностях. Plessey System 250](#1970-год-адресация-основанная-на-возможностях-plessey-system-250)
    - [1973 год. Кольца защиты для сегментов. Multics](#1973-год-кольца-защиты-для-сегментов-multics)
    - [1979 год. RAII. C++](#1979-год-raii-c)
    - [1998 год. Stack protector. GCC](#1998-год-stack-protector-gcc)
    - [2001 год. Рандомизация размещения адресного пространства. Linux](#2001-год-рандомизация-размещения-адресного-пространства-linux)
    - [2002 год. Интерпретация машинного кода. Valgrind](#2002-год-интерпретация-машинного-кода-valgrind)
    - [2005 год. Аллокатор спец. назначения. DieHard](#2005-год-аллокатор-спец-назначения-diehard)
    - [2012 год. Санитайзер. Address Sanitazer](#2012-год-санитайзер-address-sanitazer)
    - [2014 год. Тэггированная архитектура. LowRISC](#2014-год-тэггированная-архитектура-lowrisc)
    - [2015 год. Intel MPX](#2015-год-intel-mpx)
    - [2018 год. Arm MTE](#2018-год-arm-mte)
    - [2015 год. Borrow Checker. Rust](#2015-год-borrow-checker-rust)
  - [Ссылки](#ссылки)

## Введение

Высокий уровень развития компьютерных технологий - наличие
специализированных языков программирования, позволяющих нам реализовывать
чрезвычайно комплексные прикладные системы, концентрируясь в основном на
бизнес-логике и редко задумываясь об особенностях низлежащих слоев, из
которых состоит операционное окружение нашего решения.

Под низлежащими слоями здесь я понимаю аппаратную составляющую среды
исполнения, а также операционную систему. С этими компонентами обычно
непросто работать, ведь они, являясь более универсальными, предполагают
наличие расширенных возможностей пользователя и высокую конфигурируемость,
а с этим приходит и сложность использования.

Например, при разработке бэкенд
приложения на языке программирования [Scala][2], мы редко задумываемся о
решении проблем размещения объектов в памяти компьютера, ведь ответственность
за управление памятью берет на себя среда исполнения языка (далее рантайм) -
[Java VM][3], реализуя, что называется, автоматическое управление памятью. А
ведь любая программа оперирует с данными, неизбежно хранящимися в конечном
счете в памяти компьютера, поэтому никак не обойтись без реализации управления
памятью.

## Проблема

Рассмотрим компьютер,
спроектированный по принципам фон-неймановской архитектуры - наиболее
вероятная среда исполнения для нашего приложения. Он соответвует
модели вычислений [RAM-машины][4], состоящей из памяти, представляющей
собой массив ячеек, и процессора, способного производить операции чтения и
записи с ячейками памяти, а также другие операции с данными, находящимися
в памяти.

Проблема такой модели заключается в том, что образ последовательности
инструкций процессора, полученной из исходного кода программы, написанной
человеком путем трансляции, представляемый в сознании разработчика имеет
логический смысл, который может отличаться от действительного ассемблерного
кода, который может получиться неккоректным из-за ошибки программиста.
Однако процессор, оперируя с данными как с массивом бит, стирает семантику
кода и позволяет выполнять последовательности действий, лишенные логики
с точки зрения человека, что может привести к исполнению неккоретного кода и
повлечь за собой разной степени реальные проблемы, о который пойдет речь позже.
Например, программист может разместить в одной ячейке памяти целое число, а
в другой строку из 3 символов, после чего по ошибке выполнить операцию сложения,
что явно является некорректным действием.

Так как наличие ошибок в программах неизбежно, то требуется иметь механизмы
защиты от выполнения подобного неккорекного кода. Одним из направлений
решения данной проблемы является обеспечение безопасности памяти.

## Безопасность и ошибки при работе с памятью

[Безопасность памяти][5] - состояние программы при котором все ее
доступы к памяти корректны.

Доступ к памяти корректен тогда и только тогда, когда его выполнение
не может привести к ошибке программы.

Ошибка программы - ошибка, приводящая к неожиданному поведению
программы и, как следствие, выдаче некорректного результата.

## Эволюция средств обеспечения безопасности памяти

- https://en.wikipedia.org/w/index.php?title=Memory_safety&oldid=1185104456
- https://en.wikipedia.org/wiki/Memory_protection

### 1944 год. Гарвардская архитектура. Марк 1

https://habr.com/ru/companies/serverspace/articles/777542/
  
### 1959 год. Сборка мусора. Lisp

called reclamation
http://www-formal.stanford.edu/jmc/recursive.pdf

### 1960 год. Проверка выхода за границы массива. ALGOL 60

https://en.wikipedia.org/wiki/ALGOL_60

### 1961 год. Тэгированная архитектура. B5000

https://www.memorymanagement.org/glossary/t.html#tagged.architecture
https://en.wikipedia.org/wiki/Tagged_architecture

### 1961 год. Сегментная память. B5000

https://homes.cs.washington.edu/~levy/capabook/Chapter1.pdf

### 1962 год. Страничная память. Atlas

https://en.wikipedia.org/wiki/Atlas_(computer)
https://en.wikipedia.org/wiki/Virtual_memory#History

### 1964 год. Ключи защиты памяти. System/360

https://en.wikipedia.org/wiki/Memory_protection#Protection_keys
https://en.wikipedia.org/wiki/IBM_System/360

### 1970 год. Адресация, основанная на возможностях. Plessey System 250

https://en.wikipedia.org/wiki/Capability-based_addressing
https://en.wikipedia.org/wiki/Plessey_System_250

### 1973 год. Кольца защиты для сегментов. Multics

https://en.wikipedia.org/wiki/Multics
https://web.mit.edu/Saltzer/www/publications/TRs+TMs/Multics/TR-123.pdf

### 1979 год. RAII. C++

https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization

### 1998 год. Stack protector. GCC

https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries
https://www.usenix.org/legacy/publications/library/proceedings/sec98/full_papers/cowan/cowan_html/cowan.html

### 2001 год. Рандомизация размещения адресного пространства. Linux

https://www.mdpi.com/2076-3417/9/14/2928

### 2002 год. Интерпретация машинного кода. Valgrind

https://valgrind.org/docs/pubs.html

### 2005 год. Аллокатор спец. назначения. DieHard

https://github.com/emeryberger/DieHard
https://github.com/emeryberger/DieHard/blob/master/docs/pldi2006-diehard.pdf

### 2012 год. Санитайзер. Address Sanitazer

https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf

### 2014 год. Тэггированная архитектура. LowRISC

https://www.cl.cam.ac.uk/~jrrk2/downloads/lowRISC-memo-2014-001.pdf

### 2015 год. Intel MPX

https://intel-mpx.github.io/

### 2018 год. Arm MTE

https://www.youtube.com/watch?v=UwMt0e_dC_Q
https://arxiv.org/pdf/2209.00307.pdf

### 2015 год. Borrow Checker. Rust

https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html

## Ссылки

[1]: https://en.wikipedia.org/wiki/Memory_safety
[2]: https://www.scala-lang.org
[3]: https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-1.html#jvms-1.2
[4]: https://www.cse.cuhk.edu.hk/~taoyf/course/comp3506/lec/ram.pdf
[5]: https://digital.car.chula.ac.th/cgi/viewcontent.cgi?article=3284&context=chulaetd
